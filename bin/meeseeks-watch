#!/usr/bin/env python3

import sys
import logging
import signal
import os
import time
import threading
import glob

from meeseeks.util import cmdline_parser, read_cfg_files
from meeseeks.client import Client
from meeseeks.watch import Watch

global CFG,WATCH,CLIENT,SHUTDOWN,logger
logger=None
CLIENT=None
CFG={'cleanup':300} #default config
WATCH={} #watch threads we're running 
SHUTDOWN=threading.Event()   

def usage():

    print("""
meeseeks-watch [key=value]... [config-file]
    watches files, submits jobs

JSON config format, can also be specified on command line as key.subkey..=value|value,value
{
    "name" : <string> name for logging
    "apply" : <template> set template for all watches
    "defaults" : { defaults for all other sections },
    "client" : { configuration for connecting to meeseeks },
    "template" : {
        "<name>": { defines a watch template, see watch spec }
    },
    "watch" : {
        "<name>": { 
            "template": <name> applies a template to this watch config.
            "path" : <path to watch>
            "glob" : <pattern> | [ <pattern>, ... ]
            
            (see README for all watch options)

            "jobs" : [
                { jobspec } | [ {jobspec}, ... ] ,
                    jobspec(s) to submit on first (usually newest) file/fileset in the list(s)
                ,   
                    {} | [{},...]
                    jobspec(s) to submit on next file/fileset...
                , ..... ,
                    {} | [{},...]
                    last jobspec(s) will be submitted on all other unprocessed files
            ]
        } 
    }
}
""")

def apply_config(**cfg):
    global CFG,CLIENT,WATCH,logger
    logger.info('reloading config')
    CFG.update(cfg)
    #load config defaults
    defaults=CFG.get('defaults',{})

    #init client
    if not CLIENT: 
        ccfg={'refresh':10}
        ccfg.update(defaults)
        ccfg.update(cfg.get('client',{}))
        CLIENT=Client(**ccfg)
        CLIENT.wait() #wait for the client to sync initial state

    #configure watch threads
    watch=cfg.get('watch',{})
    #set global template
    apply=cfg.get('apply')
    if apply:
        try: 
            logger.info('applying template %s'%apply)
            watch=dict(('%s-%s'%(apply,w),d) for (w,d) in watch.items())
            for d in watch.values(): d.update(template=apply)
        except Exception as e: logger.error(e)

    for w in WATCH.copy(): #stop removed watches
        if w not in watch: stop_watch(w)
    
    for w in watch.keys(): #start/config watches
        wcfg=defaults.copy()
        #apply template, template[None] will auto-apply to all
        wcfg.update(cfg.get('template',{}).get(watch[w].get('template'),{})) 
        #apply config
        wcfg.update(watch[w])
        if w not in WATCH: #add new
            logger.info('adding watch %s'%w)
            WATCH[w]=Watch(w,client=CLIENT,**wcfg)
        else: WATCH[w].config(**wcfg) #reconfigure existing

def stop_watch(w):
    global WATCH
    wt=WATCH[w]
    wt.shutdown.set()
    logger.info('stopping %s'%wt.name)
    wt.join()
    del WATCH[w]

def signal_stop(*args):
    global SHUTDOWN,logger
    logger.debug(args)
    SHUTDOWN.set()

def signal_reload(*args):
    logger.debug(args)
    apply_config(**config())

def config():
    global logger
    cfgargs,args=cmdline_parser(sys.argv[1:])
    cfg=read_cfg_files(args)
    cfg.update(cfgargs)
    logging.basicConfig(**cfg.get('logging',{'level':logging.INFO}))
    logger=logging.getLogger(name=cfg.get('name',os.path.basename(sys.argv[0])))
    return cfg


#do we have args?
if len(sys.argv) < 2: sys.exit(usage())

#get config
apply_config(**config())

#set signal handlers
signal.signal(signal.SIGINT,signal_stop)
signal.signal(signal.SIGTERM,signal_stop)
signal.signal(signal.SIGHUP,signal_reload)

#slow state file cleanup
while not SHUTDOWN.is_set(): 
    if CFG.get('cleanup'):
        paths=[w.path for w in WATCH.values()]
        for path in paths:
            if not path: continue
            if SHUTDOWN.is_set(): break
            logger.debug('cleaning up %s'%path)
            hidden_files=glob.glob(os.path.join(path,'._*'))
            for hf in hidden_files:
                if SHUTDOWN.is_set(): break
                #from ._name_index_file.state get file.state, strip off state
                file='.'.join( os.path.split(hf)[1].split('_',4)[3].split('.')[:-1] )
                try:
                    if not os.path.exists(os.path.join(path,file)):
                        logger.debug('%s %s does not exist, removed %s'%(path,file,hf))
                        os.unlink(hf)
                except Exception as e: logger.debug(e)
            time.sleep(1)
        c=0
        #interruptible sleep until next cleanup
        while not SHUTDOWN.is_set():
            c+=1
            time.sleep(1)
            if c > CFG['cleanup']: break
    else: time.sleep(1)

#shut down all watches
for w in list(WATCH.keys()): stop_watch(w)

#close client to ensure state is synced
logger.info('shutting down')
CLIENT.close()